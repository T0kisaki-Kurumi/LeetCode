1.5 先在开头确定一个窗口的初始值，再移动窗口，如果窗口的左端能删就删，进一步减小窗口大小。

2.2 如果删，就不能移动cur，因为有可能下一个还是要删的。
    还可以用递归写。

2.4 一定要判断cur是否为空指针，不要判断cur->next，一个是有可能输入的head就为空指针，另一个是链表的最后一个元素的next为空，直接跳出循环不执行了。
    还可以用递归写。递归的时候每次记得让cur->next为空指针，否则原来的head的next会遗漏，形成环。

3.6 只需要计算次数，可以用哈希。

3.8 注意处理最内层2个数时候可以用双指针。

3.9 注意样例取值范围

4.1 swap函数的使用

4.4 去除空格的两种巧妙方式

4.5 注意不使用额外空间的方法

4.6 KMP算法

4.7 两种方法

6.3 获取队列长度

6.4 检查栈非空

6.5 string当作容器的使用

6.6 string转int的方法

6.7 预先开辟好vector的空间比动态增加快一点

6.8 类内自定义排序规则的方法

7.3.3 不提前搞一个初始左节点栈的方法

7.4 统一迭代遍历法

7.11 ①递归法 ②二分法

7.12 递归中遇到不符合要求跳出递归的方法

7.13 迭代法,int转string方法

7.16 递归法

7.19 单调栈法

7.23 两种递归方法

7.25 Morris遍历

7.26 递归法。如果p或q不在这个树中呢

7.30 递归比迭代简单一万倍

7.31 迭代法

7.33 迭代法

8.2 二进制法

8.8 去重方法

8.9 dp的遍历顺序、substr的用法

8.11 二进制法

8.14 去重方法

8.19 数据结构

8.20 对一个已初始化的vector重新初始化

9.3 贪心

9.4 dp法及优化的dp法、线段树

9.6 dp法

9.8 优化

9.9 只排序一次

9.11 思路

9.12 双向遍历、单向遍历

9.14 数据结构

9.17 排序标准

9.22 int转string方法,遍历顺序

9.23 状态设置

10.9 思路